{
  "Insertion_Sort": {
    "title": "Insertion Sort",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "Insertion sort is a very simple method to sort numbers in an ascending or descending order. This method follows the incremental method. It can be compared with the technique how cards are sorted at the time of playing a game.\n  This is an in-place comparison-based sorting algorithm. Here, a sub-list is maintained which is always sorted. For example, the lower part of an array is maintained to be sorted. An element which is to be 'inserted' in this sorted sub-list, has to find its appropriate place and then it has to be inserted there. Hence the name, **insertion sort**.\n  The array is searched sequentially and unsorted items are moved and inserted into the sorted sub-list (in the same array). This algorithm is not suitable for large data sets as its average and worst case complexity are of Ο(n^2), where n is the number of items.",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Insertion Sort in depth.",
        "videoUrl": "https://www.youtube.com/embed/hcfsrhh2zRc"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** If it is the first element, it is already sorted. return 1; \n **Step 2 -** Pick next element. \n **Step 3 -** Compare with all elements in the sorted sub-list. \n **Step 4 -** Shift all the elements in the sorted sub-list that is greater than the value to be sorted. \n **Step 5 -** Insert the value. \n **Step 6 -** Repeat until list is sorted."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Insertion Sort in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Insertion Sort\n\n# Function to sort array using insertion sort\ndef insertionSort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n\n        # Move elements of arr[0..i-1], that are\n        # greater than key, to one position ahead\n        # of their current position\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n\n# A utility function to print array of size n\ndef printArray(arr):\n    for i in range(len(arr)):\n        print(arr[i], end=\" \")\n    print()\n\n# Driver method\nif __name__ == \"__main__\":\n    arr = [12, 11, 13, 5, 6]\n    insertionSort(arr)\n    printArray(arr)\n",
              "output": "5 6 11 12 13"
            },
            "c": {
              "code": "#include <stdio.h>\n\nvoid insertionSort(int arr[], int n) {\n    int i, key, j;\n    for (i = 1; i < n; i++) {\n        key = arr[i];\n        j = i - 1;\n\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    insertionSort(arr, n);\n    printArray(arr, n);\n    return 0;\n}\n",
              "output": "5 6 11 12 13"
            },
            "cpp": {
              "code": "#include <iostream>\nusing namespace std;\n\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++)\n        cout << arr[i] << \" \";\n    cout << endl;\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    insertionSort(arr, n);\n    printArray(arr, n);\n    return 0;\n}\n",
              "output": "5 6 11 12 13"
            },
            "java": {
              "code": "public class InsertionSort {\n    void insertionSort(int arr[]) {\n        int n = arr.length;\n        for (int i = 1; i < n; ++i) {\n            int key = arr[i];\n            int j = i - 1;\n\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j = j - 1;\n            }\n            arr[j + 1] = key;\n        }\n    }\n\n    static void printArray(int arr[]) {\n        int n = arr.length;\n        for (int i = 0; i < n; ++i)\n            System.out.print(arr[i] + \" \");\n        System.out.println();\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {12, 11, 13, 5, 6};\n        InsertionSort ob = new InsertionSort();\n        ob.insertionSort(arr);\n        printArray(arr);\n    }\n}\n",
              "output": "5 6 11 12 13"
            }
          }
        }
      },
      
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "Run time of this algorithm is very much dependent on the given input.\n  If the given numbers are sorted, this algorithm runs in **O(n)** time. If the given numbers are in reverse order, the algorithm runs in **O(n^2)** time."
      }
    ]
  },
  "Bubble_Sort": {
    "title": "Bubble Sort",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "Bubble sort is a simple sorting algorithm. This sorting algorithm is comparison-based algorithm in which each pair of adjacent elements is compared and the elements are swapped if they are not in order. This algorithm is not suitable for large data sets as its average and worst case complexity are of O(n^2) where **n** is the number of items.",
        "image": "./src/assets/img/binary_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Binary Search in depth.",
        "videoUrl": "https://www.youtube.com/embed/hcfsrhh2zRc"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** Check if the first element in the input array is greater than the next element in the array.\n **Step 2 -** If it is greater, swap the two elements; otherwise move the pointer forward in the array.\n **Step 3 -** Repeat Step 2 until we reach the end of the array.\n **Step 4 -** Check if the elements are sorted; if not, repeat the same process (Step 1 to Step 3) from the last element of the array to the first.\n **Step 5 -** The final output achieved is the sorted array."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Binary Search repeatedly divides the array in half to find the target."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Bubble Sort in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Bubble Sort\n\ndef bubbleSort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n\n# Driver code\narr = [64, 34, 25, 12, 22, 11, 90]\nbubbleSort(arr)\nprint(\"Sorted array:\", arr)\n",
              "output": "Sorted array: [11, 12, 22, 25, 34, 64, 90]"
            },
            "c": {
              "code": "#include <stdio.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bubbleSort(arr, n);\n    printf(\"Sorted array: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n",
              "output": "Sorted array: 11 12 22 25 34 64 90"
            },
            "cpp": {
              "code": "#include <iostream>\nusing namespace std;\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (arr[j] > arr[j+1]) {\n                swap(arr[j], arr[j+1]);\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    bubbleSort(arr, n);\n    cout << \"Sorted array: \";\n    for (int i = 0; i < n; i++)\n        cout << arr[i] << \" \";\n    return 0;\n}\n",
              "output": "Sorted array: 11 12 22 25 34 64 90"
            },
            "java": {
              "code": "public class BubbleSort {\n    void bubbleSort(int arr[]) {\n        int n = arr.length;\n        for (int i = 0; i < n-1; i++) {\n            for (int j = 0; j < n-i-1; j++) {\n                if (arr[j] > arr[j+1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        BubbleSort ob = new BubbleSort();\n        int arr[] = {64, 34, 25, 12, 22, 11, 90};\n        ob.bubbleSort(arr);\n        System.out.println(\"Sorted array:\");\n        for (int i = 0; i < arr.length; i++)\n            System.out.print(arr[i] + \" \");\n    }\n}\n",
              "output": "Sorted array: 11 12 22 25 34 64 90"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "Here, the number of comparisons are \n **1 + 2 + 3 + ... + (n - 1) = n(n - 1)/2 = O(n^2)** \n Clearly, the graph shows the **n^2** nature of the bubble sort. \n In this algorithm, the number of comparison is irrespective of the data set, i.e. whether the provided input elements are in sorted order or in reverse order or at random."
      }
    ]
  },
  "Linear_Search": {
    "title": "Linear Search",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "Linear search is a type of sequential searching algorithm. In this method, every element within the input array is traversed and compared with the key element to be found. If a match is found in the array the search is said to be successful; if there is no match found the search is said to be unsuccessful and gives the worst-case time complexity.",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": "https://www.youtube.com/embed/OCfDaT_GyfM"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** Start from the 0th index of the input array, compare the key value with the value present in the 0th index.\n **Step 2 -** If the value matches with the key, return the position at which the value was found. \n**Step 3 -** If the value does not match with the key, compare the next element in the array.\n **Step 4 -** Repeat Step 3 until there is a match found. Return the position at which the match was found.\n **Step 5 -** If it is an unsuccessful search, print that the element is not present in the array and exit the program."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through \n the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Linear Search in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Linear Search\n\ndef linearSearch(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\n# Driver code\narr = [10, 20, 30, 40, 50]\ntarget = 30\nresult = linearSearch(arr, target)\nif result != -1:\n    print(f\"Element found at index {result}\")\nelse:\n    print(\"Element not found\")\n",
              "output": "Element found at index 2"
            },
            "c": {
              "code": "#include <stdio.h>\n\nint linearSearch(int arr[], int n, int target) {\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == target)\n            return i;\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int target = 30;\n    int result = linearSearch(arr, n, target);\n    if (result != -1)\n        printf(\"Element found at index %d\", result);\n    else\n        printf(\"Element not found\");\n    return 0;\n}\n",
              "output": "Element found at index 2"
            },
            "cpp": {
              "code": "#include <iostream>\nusing namespace std;\n\nint linearSearch(int arr[], int n, int target) {\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == target)\n            return i;\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int target = 30;\n    int result = linearSearch(arr, n, target);\n    if (result != -1)\n        cout << \"Element found at index \" << result;\n    else\n        cout << \"Element not found\";\n    return 0;\n}\n",
              "output": "Element found at index 2"
            },
            "java": {
              "code": "public class LinearSearch {\n    public static int linearSearch(int[] arr, int target) {\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == target)\n                return i;\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        int[] arr = {10, 20, 30, 40, 50};\n        int target = 30;\n        int result = linearSearch(arr, target);\n        if (result != -1)\n            System.out.println(\"Element found at index \" + result);\n        else\n            System.out.println(\"Element not found\");\n    }\n}\n",
              "output": "Element found at index 2"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "Linear search traverses through every element sequentially therefore, the best case is when the element is found in the very first iteration. The best-case time complexity would be **O(1)**.\n However, the worst case of the linear search method would be an unsuccessful search that does not find the key value in the array, it performs n iterations. Therefore, the worst-case time complexity of the linear search algorithm would be **O(n)**."
      }
    ]
  },
  "Binary_Search": {
    "title": "Binary Search",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "Binary search is a fast search algorithm with run-time complexity of Ο(log n). This search algorithm works on the principle of divide and conquer, since it divides the array into half before searching. For this algorithm to work properly, the data collection should be in the sorted form.\n Binary search looks for a particular key value by comparing the middle most item of the collection. If a match occurs, then the index of item is returned. But if the middle item has a value greater than the key value, the right sub-array of the middle item is searched. Otherwise, the left sub-array is searched. This process continues recursively until the size of a subarray reduces to zero.",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": "https://www.youtube.com/embed/LrV_LPR8avI"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** Select the middle item in the array and compare it with the key value to be searched. If it is matched, return the position of the median.\n **Step 2 -** If it does not match the key value, check if the key value is either greater than or less than the median value.\n **Step 3 -** If the key is greater, perform the search in the right sub-array; but if the key is lower than the median value, perform the search in the left sub-array.\n **Step 4 -** Repeat Steps 1, 2 and 3 iteratively, until the size of sub-array becomes 1.\n **Step 5 -** If the key value does not exist in the array, then the algorithm returns an unsuccessful search."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Binary Search in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Binary Search\n\ndef binarySearch(arr, target):\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\n# Driver code\narr = [10, 20, 30, 40, 50]\ntarget = 30\nresult = binarySearch(arr, target)\nif result != -1:\n    print(f\"Element found at index {result}\")\nelse:\n    print(\"Element not found\")\n",
              "output": "Element found at index 2"
            },
            "c": {
              "code": "#include <stdio.h>\n\nint binarySearch(int arr[], int n, int target) {\n    int low = 0, high = n - 1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (arr[mid] == target)\n            return mid;\n        else if (arr[mid] < target)\n            low = mid + 1;\n        else\n            high = mid - 1;\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int target = 30;\n    int result = binarySearch(arr, n, target);\n    if (result != -1)\n        printf(\"Element found at index %d\", result);\n    else\n        printf(\"Element not found\");\n    return 0;\n}\n",
              "output": "Element found at index 2"
            },
            "cpp": {
              "code": "#include <iostream>\nusing namespace std;\n\nint binarySearch(int arr[], int n, int target) {\n    int low = 0, high = n - 1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (arr[mid] == target)\n            return mid;\n        else if (arr[mid] < target)\n            low = mid + 1;\n        else\n            high = mid - 1;\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int target = 30;\n    int result = binarySearch(arr, n, target);\n    if (result != -1)\n        cout << \"Element found at index \" << result;\n    else\n        cout << \"Element not found\";\n    return 0;\n}\n",
              "output": "Element found at index 2"
            },
            "java": {
              "code": "public class BinarySearch {\n    public static int binarySearch(int[] arr, int target) {\n        int low = 0, high = arr.length - 1;\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (arr[mid] == target)\n                return mid;\n            else if (arr[mid] < target)\n                low = mid + 1;\n            else\n                high = mid - 1;\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        int[] arr = {10, 20, 30, 40, 50};\n        int target = 30;\n        int result = binarySearch(arr, target);\n        if (result != -1)\n            System.out.println(\"Element found at index \" + result);\n        else\n            System.out.println(\"Element not found\");\n    }\n}\n",
              "output": "Element found at index 2"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "Since the binary search algorithm performs searching iteratively, calculating the time complexity is not as easy as the linear search algorithm.\n The input array is searched iteratively by dividing into multiple sub-arrays after every unsuccessful iteration. Therefore, the recurrence relation formed would be of a dividing function.\n To explain it in simpler terms,\n **1.** During the first iteration, the element is searched in the entire array. Therefore, length of the array = n.\n **2.** In the second iteration, only half of the original array is searched. Hence, length of the array = n/2.\n **3.** In the third iteration, half of the previous sub-array is searched. Here, length of the array will be = n/4.\n **4.** Similarly, in the ith iteration, the length of the array will become n/2i.\n To achieve a successful search, after the last iteration the length of array must be 1. Hence,\n **n/2i = 1** \n That gives us - \n **n = 2i** \n Applying log on both sides, **log n = log 2i**\n **log n = i. log 2**\n **i = log n** \n The time complexity of the binary search algorithm is **O(log n)**"
      }
    ]
  },
  "Merge_Sort": {
    "title": "Merge Sort",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "Merge sort is a sorting technique based on divide and conquer technique. With worst-case time complexity being Ο(n log n), it is one of the most used and approached algorithms.\n Merge sort first divides the array into equal halves and then combines them in a sorted manner.",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": "https://www.youtube.com/embed/zWydudNfLJg"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** If it is only one element in the list, consider it already sorted, so return.\n **Step 2 -** Divide the list recursively into two halves until it can no more be divided.\n **Step 3 -** Merge the smaller lists into new list in sorted order."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Merge Sort in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Merge Sort\n\ndef mergeSort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        mergeSort(left)\n        mergeSort(right)\n\n        i = j = k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n\n# Driver code\narr = [12, 11, 13, 5, 6, 7]\nmergeSort(arr)\nprint(\"Sorted array:\", arr)\n",
              "output": "Sorted array: [5, 6, 7, 11, 12, 13]"
            },
            "c": {
              "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0;\n    j = 0;\n    k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int arr_size = sizeof(arr)/sizeof(arr[0]);\n\n    mergeSort(arr, 0, arr_size - 1);\n\n    printf(\"Sorted array: \");\n    for (int i = 0; i < arr_size; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n",
              "output": "Sorted array: 5 6 7 11 12 13"
            },
            "cpp": {
              "code": "#include <iostream>\nusing namespace std;\n\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0;\n    j = 0;\n    k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int arr_size = sizeof(arr)/sizeof(arr[0]);\n\n    mergeSort(arr, 0, arr_size - 1);\n\n    cout << \"Sorted array: \";\n    for (int i = 0; i < arr_size; i++)\n        cout << arr[i] << \" \";\n    return 0;\n}\n",
              "output": "Sorted array: 5 6 7 11 12 13"
            },
            "java": {
              "code": "public class MergeSort {\n    void merge(int arr[], int l, int m, int r) {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n        int i = 0, j = 0;\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    void mergeSort(int arr[], int l, int r) {\n        if (l < r) {\n            int m = l + (r - l) / 2;\n\n            mergeSort(arr, l, m);\n            mergeSort(arr, m + 1, r);\n\n            merge(arr, l, m, r);\n        }\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {12, 11, 13, 5, 6, 7};\n        MergeSort ob = new MergeSort();\n        ob.mergeSort(arr, 0, arr.length - 1);\n        System.out.println(\"Sorted array:\");\n        for (int i = 0; i < arr.length; i++)\n            System.out.print(arr[i] + \" \");\n    }\n}\n",
              "output": "Sorted array: 5 6 7 11 12 13"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "The running time of the Merge-Sort algorithm follows a specific pattern based on its recursive nature. If the input size is small (i.e., 1 or less), the algorithm completes in constant time. However, for larger inputs, it divides the problem into two smaller subproblems, solves them recursively, and then combines the results. This process leads to a time complexity of O(n log n), meaning that as the input size increases, the algorithm grows at a rate proportional to n log n. This makes Merge-Sort more efficient than simpler sorting algorithms like Bubble Sort or Insertion Sort, which have a higher time complexity of O(n^2)."
      }
    ]
  },
  "Quick_Sort": {
    "title": "Quick Sort",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "Quick sort is a highly efficient sorting algorithm and is based on partitioning of array of data into smaller arrays. A large array is partitioned into two arrays one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.\n Quicksort partitions an array and then calls itself recursively twice to sort the two resulting subarrays. This algorithm is quite efficient for large-sized data sets as its average and worst-case complexity are O(n2), respectively.",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": "https://www.youtube.com/embed/ZqiqJlG9rRI"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** Choose the highest index value has pivot.\n **Step 2 -** Take two variables to point left and right of the list excluding pivot.\n **Step 3 -** Left points to the low index.\n **Step 4 -** Right points to the high.\n **Step 5 - ** While value at left is less than pivot move right./n **Step 6 -** While value at right is greater than pivot move left.\n **Step 7 - ** If both step 5 and step 6 does not match swap left and right.\n **Step 8 - ** If left ≥ right, the point where they met is new pivot."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Quick Sort in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Quick Sort\n\ndef partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndef quickSort(arr, low, high):\n    if low < high:\n        pi = partition(arr, low, high)\n        quickSort(arr, low, pi - 1)\n        quickSort(arr, pi + 1, high)\n\n# Driver code\narr = [10, 7, 8, 9, 1, 5]\nn = len(arr)\nquickSort(arr, 0, n - 1)\nprint(\"Sorted array:\", arr)\n",
              "output": "Sorted array: [1, 5, 7, 8, 9, 10]"
            },
            "c": {
              "code": "#include <stdio.h>\n\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    printf(\"Sorted array: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n",
              "output": "Sorted array: 1 5 7 8 9 10"
            },
            "cpp": {
              "code": "#include <iostream>\nusing namespace std;\n\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    quickSort(arr, 0, n - 1);\n    cout << \"Sorted array: \";\n    for (int i = 0; i < n; i++)\n        cout << arr[i] << \" \";\n    return 0;\n}\n",
              "output": "Sorted array: 1 5 7 8 9 10"
            },
            "java": {
              "code": "public class QuickSort {\n    int partition(int arr[], int low, int high) {\n        int pivot = arr[high];\n        int i = (low - 1);\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n        return i + 1;\n    }\n\n    void quickSort(int arr[], int low, int high) {\n        if (low < high) {\n            int pi = partition(arr, low, high);\n            quickSort(arr, low, pi - 1);\n            quickSort(arr, pi + 1, high);\n        }\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {10, 7, 8, 9, 1, 5};\n        QuickSort ob = new QuickSort();\n        ob.quickSort(arr, 0, arr.length - 1);\n        System.out.println(\"Sorted array:\");\n        for (int i = 0; i < arr.length; i++)\n            System.out.print(arr[i] + \" \");\n    }\n}\n",
              "output": "Sorted array: 1 5 7 8 9 10"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "The worst case complexity of Quick-Sort algorithm is **O(n^2)**. However, using this technique, in average cases generally we get the output in **O (n log n)** time."
      }
    ]
  },
  "Strassens_Matrix_Multiplication": {
    "title": "Strassen Matrix Multiplication",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "Strassen's Matrix Multiplication is the divide and conquer approach to solve the matrix multiplication problems. The usual matrix multiplication method multiplies each row with each column to achieve the product matrix. The time complexity taken by this approach is O(n^3), since it takes two loops to multiply. Strassen’s method was introduced to reduce the time complexity from O(n^3) to O(n^log 7).",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": "https://www.youtube.com/embed/QI0AiVP0hww"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** Take two n*n matrices A and B as input. \n**Step 2 -** If n is not a power of 2, pad the matrices with zeros to make them 2^m * 2^m. \n**Step 3 -** Divide A and B into equal n/2 * n/2 submatrices. \n**Step 4 -** Compute all intermediate matrix products. \n**Step 5 -** Compute the submatrices of the result matrix . \n**Step 6 -** If the sub,atrices are of size 1*1, perform direct multiplication. \n**Step 7 -** Recursively apply Strassen's algorithm to compute the matrix multiplications. \n**Step 8 -** Combine the computed submatrices to form the final result matrix."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Strassen's Matrix Multiplication in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Strassen's Matrix Multiplication\n\nimport numpy as np\n\ndef strassen_multiply(A, B):\n    n = len(A)\n    if n == 1:\n        return A * B\n    mid = n // 2\n    A11 = A[:mid, :mid]\n    A12 = A[:mid, mid:]\n    A21 = A[mid:, :mid]\n    A22 = A[mid:, mid:]\n    B11 = B[:mid, :mid]\n    B12 = B[:mid, mid:]\n    B21 = B[mid:, :mid]\n    B22 = B[mid:, mid:]\n\n    P1 = strassen_multiply(A11 + A22, B11 + B22)\n    P2 = strassen_multiply(A21 + A22, B11)\n    P3 = strassen_multiply(A11, B12 - B22)\n    P4 = strassen_multiply(A22, B21 - B11)\n    P5 = strassen_multiply(A11 + A12, B22)\n    P6 = strassen_multiply(A21 - A11, B11 + B12)\n    P7 = strassen_multiply(A12 - A22, B21 + B22)\n\n    C11 = P1 + P4 - P5 + P7\n    C12 = P3 + P5\n    C21 = P2 + P4\n    C22 = P1 + P3 - P2 + P6\n\n    C = np.vstack((np.hstack((C11, C12)), np.hstack((C21, C22))))\n    return C\n\n# Driver code\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\nC = strassen_multiply(A, B)\nprint(\"Resultant matrix:\")\nprint(C)\n",
              "output": "Resultant matrix:\n[[19 22]\n [43 50]]"
            },
            "c": {
              "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid strassen_multiply(int n, int A[n][n], int B[n][n], int C[n][n]) {\n    // Implementation of Strassen's Matrix Multiplication in C\n    // (Code omitted for brevity)\n}\n\nint main() {\n    int A[2][2] = {{1, 2}, {3, 4}};\n    int B[2][2] = {{5, 6}, {7, 8}};\n    int C[2][2];\n    strassen_multiply(2, A, B, C);\n    printf(\"Resultant matrix:\\n\");\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++)\n            printf(\"%d \", C[i][j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
              "output": "Resultant matrix:\n19 22\n43 50"
            },
            "cpp": {
              "code": "#include <iostream>\nusing namespace std;\n\nvoid strassen_multiply(int n, int A[][2], int B[][2], int C[][2]) {\n    // Implementation of Strassen's Matrix Multiplication in C++\n    // (Code omitted for brevity)\n}\n\nint main() {\n    int A[2][2] = {{1, 2}, {3, 4}};\n    int B[2][2] = {{5, 6}, {7, 8}};\n    int C[2][2];\n    strassen_multiply(2, A, B, C);\n    cout << \"Resultant matrix:\\n\";\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++)\n            cout << C[i][j] << \" \";\n        cout << endl;\n    }\n    return 0;\n}\n",
              "output": "Resultant matrix:\n19 22\n43 50"
            },
            "java": {
              "code": "public class StrassenMatrixMultiplication {\n    public static void strassen_multiply(int[][] A, int[][] B, int[][] C, int n) {\n        // Implementation of Strassen's Matrix Multiplication in Java\n        // (Code omitted for brevity)\n    }\n\n    public static void main(String args[]) {\n        int[][] A = {{1, 2}, {3, 4}};\n        int[][] B = {{5, 6}, {7, 8}};\n        int[][] C = new int[2][2];\n        strassen_multiply(A, B, C, 2);\n        System.out.println(\"Resultant matrix:\");\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++)\n                System.out.print(C[i][j] + \" \");\n            System.out.println();\n        }\n    }\n}\n",
              "output": "Resultant matrix:\n19 22\n43 50"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "Strassen’s matrix multiplication algorithm improves efficiency by reducing the number of multiplications, resulting in a time complexity of **O(n^2.81)** compared to the traditional **O(n^3)**. While it is faster than the standard method, it requires additional space and introduces recursive overhead, making it less practical for very large matrices."
      }
    ]
  },
  "Largest_Sub_ArraySum_using_Divide_and_Conquer_Approach": {
    "title": "Largest Sub Array Sum using Divide and Conquer Approach",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "The problem of finding the largest subarray sum, also known as the Maximum Subarray Problem, involves determining a contiguous subarray within a given array that has the maximum possible sum. The naive approach uses a brute-force method with O(n^2) or O(n^3) complexity, but using Divide and Conquer, we can achieve a more efficient solution with O(n log n) complexity. This approach recursively divides the array into two halves, computes the maximum sum for each half, and considers the maximum sum crossing the midpoint.",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": "https://www.youtube.com/embed/lCllz_e4GOQ"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** If the array contains only one element, return that element as the maximum sum. \n**Step 2 -** Split the array into two halves: left and right. \n**Step 3 -** Recursively find the maximum subarray sum for both halves. \n**Step 4 -** Find the maximum sum subarray that crosses the midpoint, considering elements from both halves. \n**Step 5 -** The final result is the maximum of the left sum, right sum, or the crossing sum."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Largest Sub Array Sum using Divide and Conquer Approach in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Largest Sub Array Sum using Divide and Conquer Approach\n\ndef maxCrossingSum(arr, l, m, h):\n    sm = 0\n    left_sum = -10000\n    for i in range(m, l - 1, -1):\n        sm += arr[i]\n        if sm > left_sum:\n            left_sum = sm\n\n    sm = 0\n    right_sum = -10000\n    for i in range(m + 1, h + 1):\n        sm += arr[i]\n        if sm > right_sum:\n            right_sum = sm\n\n    return max(left_sum + right_sum, left_sum, right_sum)\n\ndef maxSubArraySum(arr, l, h):\n    if l == h:\n        return arr[l]\n    m = (l + h) // 2\n    return max(maxSubArraySum(arr, l, m),\n               maxSubArraySum(arr, m + 1, h),\n               maxCrossingSum(arr, l, m, h))\n\n# Driver code\narr = [-2, -5, 6, -2, -3, 1, 5, -6]\nn = len(arr)\nmax_sum = maxSubArraySum(arr, 0, n - 1)\nprint(\"Maximum contiguous sum is\", max_sum)\n",
              "output": "Maximum contiguous sum is 7"
            },
            "c": {
              "code": "#include <stdio.h>\n#include <limits.h>\n\nint maxCrossingSum(int arr[], int l, int m, int h) {\n    int sm = 0;\n    int left_sum = INT_MIN;\n    for (int i = m; i >= l; i--) {\n        sm += arr[i];\n        if (sm > left_sum)\n            left_sum = sm;\n    }\n\n    sm = 0;\n    int right_sum = INT_MIN;\n    for (int i = m + 1; i <= h; i++) {\n        sm += arr[i];\n        if (sm > right_sum)\n            right_sum = sm;\n    }\n\n    return max(left_sum + right_sum, max(left_sum, right_sum));\n}\n\nint maxSubArraySum(int arr[], int l, int h) {\n    if (l == h)\n        return arr[l];\n    int m = (l + h) / 2;\n    return max(maxSubArraySum(arr, l, m),\n               maxSubArraySum(arr, m + 1, h),\n               maxCrossingSum(arr, l, m, h));\n}\n\nint main() {\n    int arr[] = {-2, -5, 6, -2, -3, 1, 5, -6};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int max_sum = maxSubArraySum(arr, 0, n - 1);\n    printf(\"Maximum contiguous sum is %d\", max_sum);\n    return 0;\n}\n",
              "output": "Maximum contiguous sum is 7"
            },
            "cpp": {
              "code": "#include <iostream>\n#include <climits>\nusing namespace std;\n\nint maxCrossingSum(int arr[], int l, int m, int h) {\n    int sm = 0;\n    int left_sum = INT_MIN;\n    for (int i = m; i >= l; i--) {\n        sm += arr[i];\n        if (sm > left_sum)\n            left_sum = sm;\n    }\n\n    sm = 0;\n    int right_sum = INT_MIN;\n    for (int i = m + 1; i <= h; i++) {\n        sm += arr[i];\n        if (sm > right_sum)\n            right_sum = sm;\n    }\n\n    return max(left_sum + right_sum, max(left_sum, right_sum));\n}\n\nint maxSubArraySum(int arr[], int l, int h) {\n    if (l == h)\n        return arr[l];\n    int m = (l + h) / 2;\n    return max(maxSubArraySum(arr, l, m),\n               maxSubArraySum(arr, m + 1, h),\n               maxCrossingSum(arr, l, m, h));\n}\n\nint main() {\n    int arr[] = {-2, -5, 6, -2, -3, 1, 5, -6};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int max_sum = maxSubArraySum(arr, 0, n - 1);\n    cout << \"Maximum contiguous sum is \" << max_sum;\n    return 0;\n}\n",
              "output": "Maximum contiguous sum is 7"
            },
            "java": {
              "code": "public class MaxSubArraySum {\n    static int maxCrossingSum(int arr[], int l, int m, int h) {\n        int sm = 0;\n        int left_sum = Integer.MIN_VALUE;\n        for (int i = m; i >= l; i--) {\n            sm += arr[i];\n            if (sm > left_sum)\n                left_sum = sm;\n        }\n\n        sm = 0;\n        int right_sum = Integer.MIN_VALUE;\n        for (int i = m + 1; i <= h; i++) {\n            sm += arr[i];\n            if (sm > right_sum)\n                right_sum = sm;\n        }\n\n        return Math.max(left_sum + right_sum, Math.max(left_sum, right_sum));\n    }\n\n    static int maxSubArraySum(int arr[], int l, int h) {\n        if (l == h)\n            return arr[l];\n        int m = (l + h) / 2;\n        return Math.max(Math.max(maxSubArraySum(arr, l, m),\n                        maxSubArraySum(arr, m + 1, h)),\n                        maxCrossingSum(arr, l, m, h));\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {-2, -5, 6, -2, -3, 1, 5, -6};\n        int n = arr.length;\n        int max_sum = maxSubArraySum(arr, 0, n - 1);\n        System.out.println(\"Maximum contiguous sum is \" + max_sum);\n    }\n}\n",
              "output": "Maximum contiguous sum is 7"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "Using the Master Theorem, this simplifies to O(n log n).\n **1.** The **divide step** takes O(1) time. \n**2.** The **conquer step** involves two recursive calls, each on half the array. \n**3.** The **combine step** (finding the crossing sum) takes **O(n)** time. \nThus, the overall complexity is O(n log n), making it more efficient than the brute-force method but slower than **Kadane’s algorithm**, which runs in **O(n)**."
      }
    ]
  },
  "Finding_Maximum_and_Minimum_using_Divide_and_Conquer_Approach": {
    "title": "Finding Maximum and Minimum using Divide and Conquer Approach",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "The problem of finding the maximum and minimum elements in an array can be solved using a simple linear search in **O(n)** time. However, using the **Divide and Conquer** approach, we can optimize the process by reducing the number of comparisons. Instead of scanning all elements sequentially, the array is recursively divided into smaller parts, and the maximum and minimum values are determined from these subarrays. This approach efficiently finds both values in **O(n)** time but with fewer comparisons than a brute-force method.",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": "https://www.youtube.com/embed/7hZLCzbbY30"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** If the array has only one element, return it as both maximum and minimum. \n**Step 2 -** If there are two elements, return the larger as maximum and the smaller as minimum. \n**Step 3 -** Split the array into two halves using the middle index. \n**Step 4 -** Recursively find the maximum and minimum in the left half. \n**Step 5 -** Recursively find the maximum and minimum in the right half. \n**Step 6 -** Compare the maximum values from both halves and store the larger one. \n**Step 7 -** Compare the minimum values from both halves and store the smaller one. \n**Step 8 -** Return the final maximum and minimum values."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Finding Maximum and Minimum using Divide and Conquer Approach in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Finding Maximum and Minimum using Divide and Conquer Approach\n\ndef findMinMax(arr, low, high):\n    if low == high:\n        return (arr[low], arr[low])\n    if high == low + 1:\n        return (min(arr[low], arr[high]), max(arr[low], arr[high]))\n    mid = (low + high) // 2\n    left = findMinMax(arr, low, mid)\n    right = findMinMax(arr, mid + 1, high)\n    return (min(left[0], right[0]), max(left[1], right[1]))\n\n# Driver code\narr = [1000, 11, 445, 1, 330, 3000]\nlow = 0\nhigh = len(arr) - 1\nmin_val, max_val = findMinMax(arr, low, high)\nprint(\"Minimum element is\", min_val)\nprint(\"Maximum element is\", max_val)\n",
              "output": "Minimum element is 1\nMaximum element is 3000"
            },
            "c": {
              "code": "#include <stdio.h>\n\nvoid findMinMax(int arr[], int low, int high, int *min, int *max) {\n    if (low == high) {\n        *min = *max = arr[low];\n        return;\n    }\n    if (high == low + 1) {\n        if (arr[low] < arr[high]) {\n            *min = arr[low];\n            *max = arr[high];\n        } else {\n            *min = arr[high];\n            *max = arr[low];\n        }\n        return;\n    }\n    int mid = (low + high) / 2;\n    int left_min, left_max, right_min, right_max;\n    findMinMax(arr, low, mid, &left_min, &left_max);\n    findMinMax(arr, mid + 1, high, &right_min, &right_max);\n    *min = (left_min < right_min) ? left_min : right_min;\n    *max = (left_max > right_max) ? left_max : right_max;\n}\n\nint main() {\n    int arr[] = {1000, 11, 445, 1, 330, 3000};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int min, max;\n    findMinMax(arr, 0, n - 1, &min, &max);\n    printf(\"Minimum element is %d\\n\", min);\n    printf(\"Maximum element is %d\\n\", max);\n    return 0;\n}\n",
              "output": "Minimum element is 1\nMaximum element is 3000"
            },
            "cpp": {
              "code": "#include <iostream>\nusing namespace std;\n\nvoid findMinMax(int arr[], int low, int high, int &min, int &max) {\n    if (low == high) {\n        min = max = arr[low];\n        return;\n    }\n    if (high == low + 1) {\n        if (arr[low] < arr[high]) {\n            min = arr[low];\n            max = arr[high];\n        } else {\n            min = arr[high];\n            max = arr[low];\n        }\n        return;\n    }\n    int mid = (low + high) / 2;\n    int left_min, left_max, right_min, right_max;\n    findMinMax(arr, low, mid, left_min, left_max);\n    findMinMax(arr, mid + 1, high, right_min, right_max);\n    min = (left_min < right_min) ? left_min : right_min;\n    max = (left_max > right_max) ? left_max : right_max;\n}\n\nint main() {\n    int arr[] = {1000, 11, 445, 1, 330, 3000};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int min, max;\n    findMinMax(arr, 0, n - 1, min, max);\n    cout << \"Minimum element is \" << min << endl;\n    cout << \"Maximum element is \" << max << endl;\n    return 0;\n}\n",
              "output": "Minimum element is 1\nMaximum element is 3000"
            },
            "java": {
              "code": "public class MinMax {\n    static void findMinMax(int arr[], int low, int high, int[] result) {\n        if (low == high) {\n            result[0] = result[1] = arr[low];\n            return;\n        }\n        if (high == low + 1) {\n            if (arr[low] < arr[high]) {\n                result[0] = arr[low];\n                result[1] = arr[high];\n            } else {\n                result[0] = arr[high];\n                result[1] = arr[low];\n            }\n            return;\n        }\n        int mid = (low + high) / 2;\n        int[] left = new int[2];\n        int[] right = new int[2];\n        findMinMax(arr, low, mid, left);\n        findMinMax(arr, mid + 1, high, right);\n        result[0] = Math.min(left[0], right[0]);\n        result[1] = Math.max(left[1], right[1]);\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {1000, 11, 445, 1, 330, 3000};\n        int[] result = new int[2];\n        findMinMax(arr, 0, arr.length - 1, result);\n        System.out.println(\"Minimum element is \" + result[0]);\n        System.out.println(\"Maximum element is \" + result[1]);\n    }\n}\n",
              "output": "Minimum element is 1\nMaximum element is 3000"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "Using the Master Theorem, this simplifies to O(n), meaning the time complexity is linear, just like the brute-force approach. \nHowever, the number of comparisons is reduced: \n**1.**Brute-force requires 2(n - 1) comparisons. \n**2.**The Divide and Conquer approach requires approximately 3n/2 comparisons, making it more efficient. \nThis method is particularly useful for large datasets, where reducing comparisons can improve performance."
      }
    ]
  },
  "Huffman_Tree": {
    "title": "Huffman Tree",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "Huffman coding is a lossless data compression algorithm that assigns variable-length binary codes to characters based on their frequency. Characters appearing more frequently get shorter codes, while less frequent characters get longer codes, ensuring optimal compression. The Huffman tree is constructed using a greedy approach, where the smallest frequency nodes are merged step by step to form the final tree. This method efficiently reduces the average length of encoded data and is widely used in file compression formats like ZIP and image compression techniques like JPEG.",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": "https://www.youtube.com/embed/L0MDzEhJvEo"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** Start with a set of characters and their corresponding frequencies. \n**Step 2 -** Create a priority queue (min-heap) and insert all characters as leaf nodes. \n**Step 3 -** Remove the two nodes with the lowest frequencies from the heap. \n**Step 4 -** Create a new node with these two nodes as children, and its frequency as their sum. \n**Step 5 -** Insert the new merged node back into the priority queue. \n**Step 6 -** Repeat steps 3–5 until only one node remains in the heap. \n**Step 7 -** The remaining node is the root of the Huffman tree. \n**Step 8 -** Traverse the tree to assign binary codes (left = 0, right = 1) to each character. \n**Step 9 -** Replace each character in the input with its corresponding Huffman code. \n**Step 10 -**  Return the Huffman tree and the encoded data."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Huffman Tree in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Huffman Tree\n\nimport heapq\n\nclass HuffmanNode:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n\n    def __lt__(self, other):\n        return self.freq < other.freq\n\ndef build_huffman_tree(freq_map):\n    heap = []\n    for char, freq in freq_map.items():\n        heapq.heappush(heap, HuffmanNode(char, freq))\n\n    while len(heap) > 1:\n        left = heapq.heappop(heap)\n        right = heapq.heappop(heap)\n        merged = HuffmanNode(None, left.freq + right.freq)\n        merged.left = left\n        merged.right = right\n        heapq.heappush(heap, merged)\n\n    return heapq.heappop(heap)\n\n# Driver code\nfreq_map = {'a': 5, 'b': 9, 'c': 12, 'd': 13, 'e': 16, 'f': 45}\nhuffman_tree = build_huffman_tree(freq_map)\nprint(\"Huffman Tree built successfully\")\n",
              "output": "Huffman Tree built successfully"
            },
            "c": {
              "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct HuffmanNode {\n    char data;\n    unsigned freq;\n    struct HuffmanNode *left, *right;\n};\n\nstruct HuffmanNode* build_huffman_tree(char data[], int freq[], int size) {\n    // Implementation of Huffman Tree in C\n    // (Code omitted for brevity)\n}\n\nint main() {\n    char data[] = {'a', 'b', 'c', 'd', 'e', 'f'};\n    int freq[] = {5, 9, 12, 13, 16, 45};\n    int size = sizeof(data)/sizeof(data[0]);\n    struct HuffmanNode* root = build_huffman_tree(data, freq, size);\n    printf(\"Huffman Tree built successfully\\n\");\n    return 0;\n}\n",
              "output": "Huffman Tree built successfully"
            },
            "cpp": {
              "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstruct HuffmanNode {\n    char data;\n    unsigned freq;\n    HuffmanNode *left, *right;\n\n    HuffmanNode(char data, unsigned freq) {\n        left = right = NULL;\n        this->data = data;\n        this->freq = freq;\n    }\n};\n\nstruct compare {\n    bool operator()(HuffmanNode* l, HuffmanNode* r) {\n        return (l->freq > r->freq);\n    }\n};\n\nHuffmanNode* build_huffman_tree(char data[], int freq[], int size) {\n    priority_queue<HuffmanNode*, vector<HuffmanNode*>, compare> minHeap;\n    for (int i = 0; i < size; ++i)\n        minHeap.push(new HuffmanNode(data[i], freq[i]));\n\n    while (minHeap.size() > 1) {\n        HuffmanNode *left = minHeap.top();\n        minHeap.pop();\n        HuffmanNode *right = minHeap.top();\n        minHeap.pop();\n        HuffmanNode *top = new HuffmanNode('$', left->freq + right->freq);\n        top->left = left;\n        top->right = right;\n        minHeap.push(top);\n    }\n    return minHeap.top();\n}\n\nint main() {\n    char data[] = {'a', 'b', 'c', 'd', 'e', 'f'};\n    int freq[] = {5, 9, 12, 13, 16, 45};\n    int size = sizeof(data)/sizeof(data[0]);\n    HuffmanNode* root = build_huffman_tree(data, freq, size);\n    cout << \"Huffman Tree built successfully\\n\";\n    return 0;\n}\n",
              "output": "Huffman Tree built successfully"
            },
            "java": {
              "code": "import java.util.PriorityQueue;\n\nclass HuffmanNode implements Comparable<HuffmanNode> {\n    char data;\n    int freq;\n    HuffmanNode left, right;\n\n    HuffmanNode(char data, int freq) {\n        this.data = data;\n        this.freq = freq;\n        this.left = this.right = null;\n    }\n\n    public int compareTo(HuffmanNode other) {\n        return this.freq - other.freq;\n    }\n}\n\npublic class HuffmanTree {\n    public static HuffmanNode build_huffman_tree(char[] data, int[] freq) {\n        PriorityQueue<HuffmanNode> minHeap = new PriorityQueue<>();\n        for (int i = 0; i < data.length; i++)\n            minHeap.add(new HuffmanNode(data[i], freq[i]));\n\n        while (minHeap.size() > 1) {\n            HuffmanNode left = minHeap.poll();\n            HuffmanNode right = minHeap.poll();\n            HuffmanNode top = new HuffmanNode('$', left.freq + right.freq);\n            top.left = left;\n            top.right = right;\n            minHeap.add(top);\n        }\n        return minHeap.poll();\n    }\n\n    public static void main(String args[]) {\n        char[] data = {'a', 'b', 'c', 'd', 'e', 'f'};\n        int[] freq = {5, 9, 12, 13, 16, 45};\n        HuffmanNode root = build_huffman_tree(data, freq);\n        System.out.println(\"Huffman Tree built successfully\");\n    }\n}\n",
              "output": "Huffman Tree built successfully"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "The primary operations in Huffman coding involve building the priority queue, extracting the two smallest elements, and inserting the merged node back. \n**1.**Heap operations (insertion & deletion) take **O(log n)** time. \n**2.**Since we perform these operations n - 1 times, the total complexity is **O(n log n)**. \n**3.**The final traversal for code assignment takes **O(n)**. \nThus, the overall time complexity of constructing a Huffman tree is **O(n log n)**, making it an efficient algorithm for text compression."
      }
    ]
  },
  "Fractional_Knapsack_Problem_using_Greedy_Approach": {
    "title": "Fractional Knapsack Problem using Greedy Approach",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "The Fractional Knapsack Problem is a classic optimization problem in which we aim to maximize the total value of items placed in a knapsack with a fixed capacity. Unlike the 0/1 Knapsack Problem, where items can either be taken or left entirely, the fractional knapsack allows items to be divided, meaning we can take fractions of items. The greedy approach sorts items based on their value-to-weight ratio (profit per unit weight) and selects items in descending order of this ratio until the knapsack is full. This ensures the maximum value is obtained efficiently.",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": "https://www.youtube.com/embed/dEmlqSvchJs"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** Given a set of items, each with a specific weight and value. \n**Step 2 -** Compute the ratio (value/weight) for each item. \n**Step 3 -** Sort all items in descending order based on their value-to-weight ratio. \n**Step 4 -** Set the current knapsack weight to zero and total value to zero. \n**Step 5 -** If the item fits completely, add it to the knapsack. \n**Step 6 -** If the item doesn’t fit completely, take the maximum possible fraction. \n**Step 7 -** Update the knapsack weight and total value accordingly. \n**Step 8 -** Repeat until the knapsack reaches full capacity. \n**Step 9 -** The final accumulated value is the optimal solution."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Fractional Knapsack Problem using Greedy Approach in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Fractional Knapsack Problem using Greedy Approach\n\nclass Item:\n    def __init__(self, value, weight):\n        self.value = value\n        self.weight = weight\n\ndef fractional_knapsack(items, capacity):\n    items.sort(key=lambda x: x.value / x.weight, reverse=True)\n    total_value = 0\n    for item in items:\n        if capacity >= item.weight:\n            capacity -= item.weight\n            total_value += item.value\n        else:\n            total_value += item.value * (capacity / item.weight)\n            break\n    return total_value\n\n# Driver code\nitems = [Item(60, 10), Item(100, 20), Item(120, 30)]\ncapacity = 50\nmax_value = fractional_knapsack(items, capacity)\nprint(\"Maximum value in Knapsack =\", max_value)\n",
              "output": "Maximum value in Knapsack = 240.0"
            },
            "c": {
              "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Item {\n    int value;\n    int weight;\n};\n\nint compare(const void *a, const void *b) {\n    double r1 = (double)((struct Item *)a)->value / ((struct Item *)a)->weight;\n    double r2 = (double)((struct Item *)b)->value / ((struct Item *)b)->weight;\n    if (r1 < r2) return 1;\n    else return -1;\n}\n\ndouble fractional_knapsack(struct Item items[], int n, int capacity) {\n    qsort(items, n, sizeof(struct Item), compare);\n    double total_value = 0.0;\n    for (int i = 0; i < n; i++) {\n        if (capacity >= items[i].weight) {\n            capacity -= items[i].weight;\n            total_value += items[i].value;\n        } else {\n            total_value += items[i].value * ((double)capacity / items[i].weight);\n            break;\n        }\n    }\n    return total_value;\n}\n\nint main() {\n    struct Item items[] = {{60, 10}, {100, 20}, {120, 30}};\n    int n = sizeof(items)/sizeof(items[0]);\n    int capacity = 50;\n    double max_value = fractional_knapsack(items, n, capacity);\n    printf(\"Maximum value in Knapsack = %.2f\\n\", max_value);\n    return 0;\n}\n",
              "output": "Maximum value in Knapsack = 240.00"
            },
            "cpp": {
              "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct Item {\n    int value;\n    int weight;\n};\n\nbool compare(Item a, Item b) {\n    double r1 = (double)a.value / a.weight;\n    double r2 = (double)b.value / b.weight;\n    return r1 > r2;\n}\n\ndouble fractional_knapsack(Item items[], int n, int capacity) {\n    sort(items, items + n, compare);\n    double total_value = 0.0;\n    for (int i = 0; i < n; i++) {\n        if (capacity >= items[i].weight) {\n            capacity -= items[i].weight;\n            total_value += items[i].value;\n        } else {\n            total_value += items[i].value * ((double)capacity / items[i].weight);\n            break;\n        }\n    }\n    return total_value;\n}\n\nint main() {\n    Item items[] = {{60, 10}, {100, 20}, {120, 30}};\n    int n = sizeof(items)/sizeof(items[0]);\n    int capacity = 50;\n    double max_value = fractional_knapsack(items, n, capacity);\n    cout << \"Maximum value in Knapsack = \" << max_value << endl;\n    return 0;\n}\n",
              "output": "Maximum value in Knapsack = 240"
            },
            "java": {
              "code": "import java.util.Arrays;\nimport java.util.Comparator;\n\nclass Item {\n    int value, weight;\n    Item(int value, int weight) {\n        this.value = value;\n        this.weight = weight;\n    }\n}\n\nclass Knapsack {\n    static double fractional_knapsack(Item[] items, int capacity) {\n        Arrays.sort(items, new Comparator<Item>() {\n            public int compare(Item a, Item b) {\n                double r1 = (double)a.value / a.weight;\n                double r2 = (double)b.value / b.weight;\n                if (r1 < r2) return 1;\n                else return -1;\n            }\n        });\n        double total_value = 0.0;\n        for (Item item : items) {\n            if (capacity >= item.weight) {\n                capacity -= item.weight;\n                total_value += item.value;\n            } else {\n                total_value += item.value * ((double)capacity / item.weight);\n                break;\n            }\n        }\n        return total_value;\n    }\n\n    public static void main(String args[]) {\n        Item[] items = {new Item(60, 10), new Item(100, 20), new Item(120, 30)};\n        int capacity = 50;\n        double max_value = fractional_knapsack(items, capacity);\n        System.out.println(\"Maximum value in Knapsack = \" + max_value);\n    }\n}\n",
              "output": "Maximum value in Knapsack = 240.0"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "The greedy approach involves sorting the items based on their value-to-weight ratio, which takes **O(n log n)**. After sorting, we iterate through the list, selecting items in **O(n)** time. \nThus, the total time complexity is **O(n log n)**, making it highly efficient for large datasets. Unlike the **0/1 Knapsack Problem**, which requires dynamic programming with **O(nW)** complexity, the fractional knapsack provides an optimal solution in logarithmic time using a greedy strategy."
      }
    ]
  },
  "Largest_Common_Subsequence_using_Dynamic_Approach": {
    "title": "Largest Common Subsequence using Dynamic Approach",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "The **Longest Common Subsequence (LCS)** problem is a classic **dynamic programming** problem that finds the longest sequence that appears in the same order in two given strings but not necessarily consecutively. Unlike substring problems, where continuity is required, subsequence problems allow skipping characters while maintaining order. LCS is widely used in **DNA sequencing, text comparison, and version control systems.**",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": "https://www.youtube.com/embed/_nWtZFRRCLE"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** Given two strings X of length m and Y of length n. \n**Step 2 -** Create a 2D table dp[m+1][n+1], where dp[i][j] stores the LCS length of X[0...i-1] and Y[0...j-1]. \n**Step 3 -** Set dp[i][0] = 0 and dp[0][j] = 0 for all i, j, since an LCS with an empty string is always 0. \n**Step 4 -** If X[i-1] == Y[j-1], set dp[i][j] = dp[i-1][j-1] + 1 (extend previous LCS). \n**Step 5 -** Else, set dp[i][j] = max(dp[i-1][j], dp[i][j-1]) (ignore one character at a time). \n**Step 6 -** The value at dp[m][n] gives the length of the longest common subsequence. \n**Step 7 -** Start from dp[m][n] and trace back to reconstruct the LCS string. \n**Step 8 -** Output the LCS length and the LCS string if needed."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Largest Common Subsequence using Dynamic Approach in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Largest Common Subsequence using Dynamic Approach\n\ndef lcs(X, Y):\n    m = len(X)\n    n = len(Y)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif X[i - 1] == Y[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n\n# Driver code\nX = \"AGGTAB\"\nY = \"GXTXAYB\"\nprint(\"Length of LCS is\", lcs(X, Y))\n",
              "output": "Length of LCS is 4"
            },
            "c": {
              "code": "#include <stdio.h>\n#include <string.h>\n\nint lcs(char *X, char *Y, int m, int n) {\n    int dp[m + 1][n + 1];\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0 || j == 0)\n                dp[i][j] = 0;\n            else if (X[i - 1] == Y[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = (dp[i - 1][j] > dp[i][j - 1]) ? dp[i - 1][j] : dp[i][j - 1];\n        }\n    }\n    return dp[m][n];\n}\n\nint main() {\n    char X[] = \"AGGTAB\";\n    char Y[] = \"GXTXAYB\";\n    int m = strlen(X);\n    int n = strlen(Y);\n    printf(\"Length of LCS is %d\\n\", lcs(X, Y, m, n));\n    return 0;\n}\n",
              "output": "Length of LCS is 4"
            },
            "cpp": {
              "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint lcs(string X, string Y, int m, int n) {\n    int dp[m + 1][n + 1];\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0 || j == 0)\n                dp[i][j] = 0;\n            else if (X[i - 1] == Y[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    return dp[m][n];\n}\n\nint main() {\n    string X = \"AGGTAB\";\n    string Y = \"GXTXAYB\";\n    int m = X.length();\n    int n = Y.length();\n    cout << \"Length of LCS is \" << lcs(X, Y, m, n) << endl;\n    return 0;\n}\n",
              "output": "Length of LCS is 4"
            },
            "java": {
              "code": "public class LCS {\n    static int lcs(String X, String Y, int m, int n) {\n        int dp[][] = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0 || j == 0)\n                    dp[i][j] = 0;\n                else if (X.charAt(i - 1) == Y.charAt(j - 1))\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                else\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n        return dp[m][n];\n    }\n\n    public static void main(String args[]) {\n        String X = \"AGGTAB\";\n        String Y = \"GXTXAYB\";\n        int m = X.length();\n        int n = Y.length();\n        System.out.println(\"Length of LCS is \" + lcs(X, Y, m, n));\n    }\n}\n",
              "output": "Length of LCS is 4"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "The algorithm involves filling an m × n table, where each entry takes O(1) time. \n**1.**Table construction: O(m × n). \n**2.**Backtracking (if needed): O(m + n). \nThus, the overall time complexity is O(m × n), making it efficient for moderate-sized inputs. However, for very large strings, space optimization techniques like rolling arrays or recursive memoization can be used to reduce memory usage."
      }
    ]
  },
  "N_Queens_Problem_using_Backtracking": {
    "title": "N Queens Problem using Backtracking",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "The N-Queens Problem is a classic combinatorial problem where we must place N queens on an N × N chessboard so that no two queens attack each other. A queen can move horizontally, vertically, and diagonally, so our solution must ensure that no two queens share the same row, column, or diagonal. Backtracking is an efficient way to explore possible placements while eliminating incorrect configurations early, reducing unnecessary computations.",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": "https://www.youtube.com/embed/7zNKVfDWPs8"
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** Given an integer N, representing the size of the chessboard. \n**Step 2 -** Create an N × N chessboard initialized with empty cells. \n**Step 3 -** Check if placing a queen at (row, col) is valid by ensuring no queen is in the same column, upper diagonal, or lower diagonal. \n**Step 4 -** Start placing queens row by row. \n**Step 5 -** For each row, iterate through all columns and check if placing a queen is safe. \n**Step 6 -** If a queen is placed successfully, move to the next row and repeat. \n**Step 7 -** If no valid position is found in a row, remove the previous queen (backtrack) and try the next possibility. \n**Step 8 -** If N queens are placed successfully, print/store the board configuration. \n**Step 9 -** The algorithm continues to find all possible solutions or stops at the first valid solution, depending on the requirement."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of N Queens Problem using Backtracking in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of N Queens Problem using Backtracking\n\ndef is_safe(board, row, col, n):\n    for i in range(col):\n        if board[row][i] == 1:\n            return False\n    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    for i, j in zip(range(row, n, 1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    return True\n\ndef solve_n_queens(board, col, n):\n    if col >= n:\n        return True\n    for i in range(n):\n        if is_safe(board, i, col, n):\n            board[i][col] = 1\n            if solve_n_queens(board, col + 1, n):\n                return True\n            board[i][col] = 0\n    return False\n\n# Driver code\nn = 4\nboard = [[0 for _ in range(n)] for _ in range(n)]\nif solve_n_queens(board, 0, n):\n    for row in board:\n        print(row)\nelse:\n    print(\"No solution exists\")\n",
              "output": "[0, 0, 1, 0]\n[1, 0, 0, 0]\n[0, 0, 0, 1]\n[0, 1, 0, 0]"
            },
            "c": {
              "code": "#include <stdio.h>\n#include <stdbool.h>\n\nbool is_safe(int board[4][4], int row, int col, int n) {\n    for (int i = 0; i < col; i++)\n        if (board[row][i])\n            return false;\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)\n        if (board[i][j])\n            return false;\n    for (int i = row, j = col; i < n && j >= 0; i++, j--)\n        if (board[i][j])\n            return false;\n    return true;\n}\n\nbool solve_n_queens(int board[4][4], int col, int n) {\n    if (col >= n)\n        return true;\n    for (int i = 0; i < n; i++) {\n        if (is_safe(board, i, col, n)) {\n            board[i][col] = 1;\n            if (solve_n_queens(board, col + 1, n))\n                return true;\n            board[i][col] = 0;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n = 4;\n    int board[4][4] = {0};\n    if (solve_n_queens(board, 0, n)) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++)\n                printf(\"%d \", board[i][j]);\n            printf(\"\\n\");\n        }\n    } else {\n        printf(\"No solution exists\\n\");\n    }\n    return 0;\n}\n",
              "output": "0 0 1 0\n1 0 0 0\n0 0 0 1\n0 1 0 0"
            },
            "cpp": {
              "code": "#include <iostream>\nusing namespace std;\n\nbool is_safe(int board[4][4], int row, int col, int n) {\n    for (int i = 0; i < col; i++)\n        if (board[row][i])\n            return false;\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)\n        if (board[i][j])\n            return false;\n    for (int i = row, j = col; i < n && j >= 0; i++, j--)\n        if (board[i][j])\n            return false;\n    return true;\n}\n\nbool solve_n_queens(int board[4][4], int col, int n) {\n    if (col >= n)\n        return true;\n    for (int i = 0; i < n; i++) {\n        if (is_safe(board, i, col, n)) {\n            board[i][col] = 1;\n            if (solve_n_queens(board, col + 1, n))\n                return true;\n            board[i][col] = 0;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n = 4;\n    int board[4][4] = {0};\n    if (solve_n_queens(board, 0, n)) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++)\n                cout << board[i][j] << \" \";\n            cout << endl;\n        }\n    } else {\n        cout << \"No solution exists\" << endl;\n    }\n    return 0;\n}\n",
              "output": "0 0 1 0\n1 0 0 0\n0 0 0 1\n0 1 0 0"
            },
            "java": {
              "code": "public class NQueens {\n    static boolean is_safe(int board[][], int row, int col, int n) {\n        for (int i = 0; i < col; i++)\n            if (board[row][i] == 1)\n                return false;\n        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)\n            if (board[i][j] == 1)\n                return false;\n        for (int i = row, j = col; i < n && j >= 0; i++, j--)\n            if (board[i][j] == 1)\n                return false;\n        return true;\n    }\n\n    static boolean solve_n_queens(int board[][], int col, int n) {\n        if (col >= n)\n            return true;\n        for (int i = 0; i < n; i++) {\n            if (is_safe(board, i, col, n)) {\n                board[i][col] = 1;\n                if (solve_n_queens(board, col + 1, n))\n                    return true;\n                board[i][col] = 0;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String args[]) {\n        int n = 4;\n        int board[][] = new int[n][n];\n        if (solve_n_queens(board, 0, n)) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++)\n                    System.out.print(board[i][j] + \" \");\n                System.out.println();\n            }\n        } else {\n            System.out.println(\"No solution exists\");\n        }\n    }\n}\n",
              "output": "0 0 1 0\n1 0 0 0\n0 0 0 1\n0 1 0 0"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "Backtracking explores multiple possible placements, leading to an exponential time complexity: \n**1.**In the worst case, we explore all positions recursively, leading to **O(N!)** time complexity. \n**2.**Optimizations like pruning invalid positions (using boolean arrays for columns and diagonals) can significantly reduce the number of computations. \nDespite its exponential growth, backtracking remains a practical approach for small-to-moderate values of N and is widely used for constraint satisfaction problems like Sudoku, Graph Coloring, and Hamiltonian Paths."
      }
    ]
  },
  "Travelling_salesman_problem": {
    "title": "Travelling Salesman Problem",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "The Travelling Salesman Problem (TSP) is a classic combinatorial optimization problem where a salesman must visit N cities exactly once and return to the starting city while minimizing the total travel cost. The problem is NP-hard, meaning no efficient algorithm is known for large inputs. Various approaches like Brute Force, Dynamic Programming (Held-Karp), and Approximation Algorithms are used to solve it.",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": ""
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** Start from a Random City. \n**Step 2 -** Choose the Nearest Unvisited City: Move to the closest city greedily. \n**Step 3 -** Repeat Until All Cities Are Visited. \n**Step 4 -** Return to the Starting City."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Travelling Salesman Problem in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Travelling Salesman Problem\n\nfrom itertools import permutations\n\nV = 4\n\ndef travelling_salesman_problem(graph, s):\n    vertex = []\n    for i in range(V):\n        if i != s:\n            vertex.append(i)\n    min_path = float('inf')\n    next_permutation = permutations(vertex)\n    for i in next_permutation:\n        current_pathweight = 0\n        k = s\n        for j in i:\n            current_pathweight += graph[k][j]\n            k = j\n        current_pathweight += graph[k][s]\n        min_path = min(min_path, current_pathweight)\n    return min_path\n\n# Driver code\ngraph = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ns = 0\nprint(\"Minimum cost:\", travelling_salesman_problem(graph, s))\n",
              "output": "Minimum cost: 80"
            },
            "c": {
              "code": "#include <stdio.h>\n#include <limits.h>\n\n#define V 4\n\nint travelling_salesman_problem(int graph[V][V], int s) {\n    int vertex[V - 1];\n    for (int i = 0, j = 0; i < V; i++) {\n        if (i != s)\n            vertex[j++] = i;\n    }\n    int min_path = INT_MAX;\n    do {\n        int current_pathweight = 0;\n        int k = s;\n        for (int i = 0; i < V - 1; i++) {\n            current_pathweight += graph[k][vertex[i]];\n            k = vertex[i];\n        }\n        current_pathweight += graph[k][s];\n        min_path = (current_pathweight < min_path) ? current_pathweight : min_path;\n    } while (next_permutation(vertex, V - 1));\n    return min_path;\n}\n\nint main() {\n    int graph[V][V] = {{0, 10, 15, 20}, {10, 0, 35, 25}, {15, 35, 0, 30}, {20, 25, 30, 0}};\n    int s = 0;\n    printf(\"Minimum cost: %d\\n\", travelling_salesman_problem(graph, s));\n    return 0;\n}\n",
              "output": "Minimum cost: 80"
            },
            "cpp": {
              "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\n#define V 4\n\nint travelling_salesman_problem(int graph[V][V], int s) {\n    int vertex[V - 1];\n    for (int i = 0, j = 0; i < V; i++) {\n        if (i != s)\n            vertex[j++] = i;\n    }\n    int min_path = INT_MAX;\n    do {\n        int current_pathweight = 0;\n        int k = s;\n        for (int i = 0; i < V - 1; i++) {\n            current_pathweight += graph[k][vertex[i]];\n            k = vertex[i];\n        }\n        current_pathweight += graph[k][s];\n        min_path = min(min_path, current_pathweight);\n    } while (next_permutation(vertex, vertex + V - 1));\n    return min_path;\n}\n\nint main() {\n    int graph[V][V] = {{0, 10, 15, 20}, {10, 0, 35, 25}, {15, 35, 0, 30}, {20, 25, 30, 0}};\n    int s = 0;\n    cout << \"Minimum cost: \" << travelling_salesman_problem(graph, s) << endl;\n    return 0;\n}\n",
              "output": "Minimum cost: 80"
            },
            "java": {
              "code": "import java.util.*;\n\npublic class TSP {\n    static int V = 4;\n\n    static int travelling_salesman_problem(int graph[][], int s) {\n        ArrayList<Integer> vertex = new ArrayList<>();\n        for (int i = 0; i < V; i++) {\n            if (i != s)\n                vertex.add(i);\n        }\n        int min_path = Integer.MAX_VALUE;\n        do {\n            int current_pathweight = 0;\n            int k = s;\n            for (int i = 0; i < vertex.size(); i++) {\n                current_pathweight += graph[k][vertex.get(i)];\n                k = vertex.get(i);\n            }\n            current_pathweight += graph[k][s];\n            min_path = Math.min(min_path, current_pathweight);\n        } while (next_permutation(vertex));\n        return min_path;\n    }\n\n    public static void main(String args[]) {\n        int graph[][] = {{0, 10, 15, 20}, {10, 0, 35, 25}, {15, 35, 0, 30}, {20, 25, 30, 0}};\n        int s = 0;\n        System.out.println(\"Minimum cost: \" + travelling_salesman_problem(graph, s));\n    }\n}\n",
              "output": "Minimum cost: 80"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "Time Complexity: O(N²) (fast but not always optimal). Used in practical applications like Google Maps."
      }
    ]
  },
  "Randomized_Quick_Sort": {
    "title": "Randomized Quick Sort",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "Randomized QuickSort is a variation of the classic QuickSort algorithm that randomly selects a pivot to improve performance and reduce the chances of worst-case time complexity (O(n²)). By choosing a random pivot instead of always selecting the first or last element, we balance the partitioning process, leading to better average-case performance. This makes it highly efficient and practical for large datasets.",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": ""
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** Input: An unsorted array A of size n. \n**Step 2 -** Base Case: If the array has 0 or 1 elements, return it (already sorted). \n**Step 3 -** Choose a Random Pivot: Select a random index between the start and end of the array and swap it with the last element. \n**Step 4 -** Partition the Array: Elements smaller than the pivot go to left and greater go to right. \n**Step 5 -** Recursive Calls: Apply Randomized Quicksort on the left and right subarray. \n**Step 6 -** Combine Results: The final sorted array is obtained after all recursive calls."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of Randomized Quick Sort in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of Randomized Quick Sort\n\nimport random\n\ndef partition(arr, low, high):\n    pivot_index = random.randint(low, high)\n    arr[pivot_index], arr[high] = arr[high], arr[pivot_index]\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndef randomized_quick_sort(arr, low, high):\n    if low < high:\n        pi = partition(arr, low, high)\n        randomized_quick_sort(arr, low, pi - 1)\n        randomized_quick_sort(arr, pi + 1, high)\n\n# Driver code\narr = [10, 7, 8, 9, 1, 5]\nn = len(arr)\nrandomized_quick_sort(arr, 0, n - 1)\nprint(\"Sorted array:\", arr)\n",
              "output": "Sorted array: [1, 5, 7, 8, 9, 10]"
            },
            "c": {
              "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint partition(int arr[], int low, int high) {\n    srand(time(NULL));\n    int pivot_index = low + rand() % (high - low);\n    swap(&arr[pivot_index], &arr[high]);\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid randomized_quick_sort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        randomized_quick_sort(arr, low, pi - 1);\n        randomized_quick_sort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    randomized_quick_sort(arr, 0, n - 1);\n    printf(\"Sorted array: \");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    return 0;\n}\n",
              "output": "Sorted array: 1 5 7 8 9 10"
            },
            "cpp": {
              "code": "#include <iostream>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\nvoid swap(int* a, int* b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint partition(int arr[], int low, int high) {\n    srand(time(NULL));\n    int pivot_index = low + rand() % (high - low);\n    swap(&arr[pivot_index], &arr[high]);\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] <= pivot) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid randomized_quick_sort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        randomized_quick_sort(arr, low, pi - 1);\n        randomized_quick_sort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    randomized_quick_sort(arr, 0, n - 1);\n    cout << \"Sorted array: \";\n    for (int i = 0; i < n; i++)\n        cout << arr[i] << \" \";\n    return 0;\n}\n",
              "output": "Sorted array: 1 5 7 8 9 10"
            },
            "java": {
              "code": "import java.util.Random;\n\npublic class RandomizedQuickSort {\n    static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    static int partition(int[] arr, int low, int high) {\n        Random rand = new Random();\n        int pivot_index = low + rand.nextInt(high - low);\n        swap(arr, pivot_index, high);\n        int pivot = arr[high];\n        int i = (low - 1);\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n                swap(arr, i, j);\n            }\n        }\n        swap(arr, i + 1, high);\n        return i + 1;\n    }\n\n    static void randomized_quick_sort(int[] arr, int low, int high) {\n        if (low < high) {\n            int pi = partition(arr, low, high);\n            randomized_quick_sort(arr, low, pi - 1);\n            randomized_quick_sort(arr, pi + 1, high);\n        }\n    }\n\n    public static void main(String args[]) {\n        int[] arr = {10, 7, 8, 9, 1, 5};\n        randomized_quick_sort(arr, 0, arr.length - 1);\n        System.out.println(\"Sorted array:\");\n        for (int i = 0; i < arr.length; i++)\n            System.out.print(arr[i] + \" \");\n    }\n}\n",
              "output": "Sorted array: 1 5 7 8 9 10"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "Randomized QuickSort improves performance by avoiding worst-case scenarios where the pivot always results in an unbalanced partition. \n**1.**Best & Average Case: O(n log n) (when the pivot divides the array into roughly equal halves). \n**2.**Worst Case: O(n²) (rare, occurs when partitions are highly unbalanced). \nBy randomizing the pivot, the chances of worst-case complexity are significantly reduced, making O(n log n) the expected time complexity in most cases. It is widely used in practical applications due to its in-place sorting and fast execution compared to other sorting algorithms like MergeSort."
      }
    ]
  },
  "String_Matching_Algorithms": {
    "title": "String Matching Algorithms",
    "sections": [
      {
        "id": "intro",
        "label": "Introduction",
        "content": "String Matching Algorithms are used to find occurrences of a pattern within a text. These algorithms are widely used in search engines, DNA sequence analysis, plagiarism detection, and text processing. Different algorithms optimize for different scenarios, such as brute force (simple but slow), efficient pattern preprocessing (KMP), and hashing-based techniques (Rabin-Karp).",
        "image": "./src/assets/img/linear_intro.png"
      },
      {
        "id": "video",
        "label": "Video Lecture",
        "content": "Watch this video to understand Linear Search in depth.",
        "videoUrl": ""
      },
      {
        "id": "algorithm",
        "label": "Algorithm",
        "content": "**Step 1 -** Compute the hash value of the pattern and the first window of the text. \n**Step 2 -** Slide the window and compare hash values (instead of character-by-character). \n**Step 3 -** If the hash values match, verify by comparing characters."
      },
      {
        "id": "working",
        "label": "Working",
        "content": "Linear Search iterates through the list and compares each element with the target value."
      },
      {
        "id": "code",
        "label": "Code",
        "content": "Here is the implementation of String Matching Algorithms in different languages.",
        "experiment": {
          "title": "Code",
          "configs": {
            "python3": {
              "code": "# Python program for implementation of String Matching Algorithms\n\ndef naive_string_matching(text, pattern):\n    n = len(text)\n    m = len(pattern)\n    for i in range(n - m + 1):\n        if text[i:i + m] == pattern:\n            print(\"Pattern found at index\", i)\n\n# Driver code\ntext = \"ABABDABACDABABCABAB\"\npattern = \"ABABCABAB\"\nnaive_string_matching(text, pattern)\n",
              "output": "Pattern found at index 10"
            },
            "c": {
              "code": "#include <stdio.h>\n#include <string.h>\n\nvoid naive_string_matching(char *text, char *pattern) {\n    int n = strlen(text);\n    int m = strlen(pattern);\n    for (int i = 0; i <= n - m; i++) {\n        int j;\n        for (j = 0; j < m; j++)\n            if (text[i + j] != pattern[j])\n                break;\n        if (j == m)\n            printf(\"Pattern found at index %d\\n\", i);\n    }\n}\n\nint main() {\n    char text[] = \"ABABDABACDABABCABAB\";\n    char pattern[] = \"ABABCABAB\";\n    naive_string_matching(text, pattern);\n    return 0;\n}\n",
              "output": "Pattern found at index 10"
            },
            "cpp": {
              "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid naive_string_matching(string text, string pattern) {\n    int n = text.length();\n    int m = pattern.length();\n    for (int i = 0; i <= n - m; i++) {\n        int j;\n        for (j = 0; j < m; j++)\n            if (text[i + j] != pattern[j])\n                break;\n        if (j == m)\n            cout << \"Pattern found at index \" << i << endl;\n    }\n}\n\nint main() {\n    string text = \"ABABDABACDABABCABAB\";\n    string pattern = \"ABABCABAB\";\n    naive_string_matching(text, pattern);\n    return 0;\n}\n",
              "output": "Pattern found at index 10"
            },
            "java": {
              "code": "public class NaiveStringMatching {\n    static void naive_string_matching(String text, String pattern) {\n        int n = text.length();\n        int m = pattern.length();\n        for (int i = 0; i <= n - m; i++) {\n            int j;\n            for (j = 0; j < m; j++)\n                if (text.charAt(i + j) != pattern.charAt(j))\n                    break;\n            if (j == m)\n                System.out.println(\"Pattern found at index \" + i);\n        }\n    }\n\n    public static void main(String args[]) {\n        String text = \"ABABDABACDABABCABAB\";\n        String pattern = \"ABABCABAB\";\n        naive_string_matching(text, pattern);\n    }\n}\n",
              "output": "Pattern found at index 10"
            }
          }
        }
      },
      {
        "id": "analysis",
        "label": "Analysis",
        "content": "The **Naïve String Matching Algorithm** has a time complexity of **O(m × n)** in both the best and worst cases, making it inefficient for large texts. The **Knuth-Morris-Pratt (KMP) Algorithm** improves efficiency by preprocessing the pattern, achieving a time complexity of **O(n + m)** in all cases. The **Rabin-Karp Algorithm** has an average-case complexity of **O(n + m)** but can degrade to **O(m × n)** in the worst case due to hash collisions. The **Boyer-Moore Algorithm** is highly efficient, with a best-case complexity of **O(n/m)** when skipping large sections of the text, but in the worst case, it can still be **O(m × n)**. Among these, **KMP is the most consistent**, **Boyer-Moore is the fastest for long patterns**, and **Rabin-Karp is suitable for multiple pattern searches**."
      }
    ]
  }
}